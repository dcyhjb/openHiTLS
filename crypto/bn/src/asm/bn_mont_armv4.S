#include "hitls_build.h"
#ifdef HITLS_CRYPTO_BN

.file   "bn_mont_armv4.S"
.text

.global MontMul_Asm
.type   MontMul_Asm, %function
.align  5
MontMul_Asm:
    ldr     r12, [sp, #4]       // r12 = size

.LCommonMul:
    stmdb   sp!, {r0}           // sp -= 4, sp = r0
    stmdb   sp!, {r4-r11, lr}   // Register is pushed into the stack, and lr is r14.

    ldr     r8 , [sp, #4*10]    // r8 = k0

    mov     r0 , r12, lsl#2     // r0 saves the number of bytes corresponding to the size.
    add     r9 , r2 , r0        // r9 = &b[size]
    str     r9 , [sp, #-4]!     // Save b[size], which is used to determine the end of the outer loop

    sub     sp , sp , r0        // Apply space for uint32_t of size
    sub     sp , sp , #4        // Apply for an extra space. The sum of two arrays whose size is size
                                // Requires an extra space for storing carry
    sub     r0 , r0 , #4        // r0 = size-1
    add     r0 , sp , r0        // r0 = &t[size-1], which is used to determine the end of the internal loop

    ldr     r5 , [r1], #4       // r5 = a[0], r1 += 4, points to a[1], equivalent tor5 = a[i++]
    ldr     r6 , [r2], #4       // r6 = b[0], r2 += 4, points to b[1], equivalent tor6 = b[i++]
    ldr     r7 , [r3], #4       // r7 = n[0], r3 += 4, points to n[1], equivalent tor7 = n[i++]

.L1stCalculateQ:
    umull   r10, r11, r5 , r6   // r10 = lo(a[0]*b[0]), r11 = hi(a[0]*b[0])
    mul     r8 , r10, r8        // q = lo( lo(a[0]*b[0]) * k0 )
    mov     r12, #0
    umlal   r10, r12, r8 , r7   // r10 += lo(q*n[0]), r12 = hi(q*n[0])
    mov     r4 , sp

.L1stReduce:
    ldr     r5 , [r1], #4       // r5 = a[1], r1 += 4, points to a[2], equivalent to r5 = a[i++]
    mov     r10, r11
    mov     r11, #0
    ldr     r7 , [r3], #4       // r7 = n[1], r3 += 4, points to n[2], equivalent to r7 = n[i++]
    mov     r14, #0
    umlal   r10, r11, r5 , r6   // r10 += lo(a[1]*b[0]), r11 = hi(a[1]*b[0])
    umlal   r12, r14, r8 , r7   // r12 += lo(q*n[1]), r14 = hi(q*n[1])
    adds    r12, r12, r10       // r12 = lo(S) + lo(a[1]*b[0]) + lo(q*n[1])
    str     r12, [r4], #4       // t[i] = r12, r4 = &t[i+1]
    adc     r12, r14, #0        // r12 = hi(S), hi(S) is lo(S) for the next loop

    cmp     r4 , r0             // If r4 points to &t[size-1], perform special processing.
    bne     .L1stReduce

    mov     r14, #0
    adds    r12, r12, r11       // r12 = hi(q*n[0]) + hi(a[i]*b[0]), hi(S) in the previous round,
                                // lo(S) in the last round
    adc     r14, r14, #0

    str     r12, [r4], #4       // t[size-1], r4 +=4, points to t[size]
    str     r14, [r4]           // t[size]

.LCalculateQ:
    sub     r6 , r4 , sp        // r6 = r4 - sp = size, at the same time r4 = &t[size]
    sub     r1 , r1 , r6        // r1 points to &a[size], r1 = &a[0] at the end of each round of the loop
    sub     r3 , r3 , r6        // r3 points to &n[size], r3 = &n[0] at the end of each round of the loop

    ldr     r5 , [r1], #4       // r5 = a[0], r1 += 4, points to a[1], equivalent tor5 = a[i++]
    ldr     r6 , [r2], #4       // r6 = b[i], r2 += 4, equivalent to r6 = b[i++]
    ldr     r7 , [r3], #4       // r7 = n[0], r3 += 4, points to n[1], equivalent to r7 = n[i++]
    ldr     r8 , [r4, #4*12]    // r4[4*12] = k0
    mov     r4 , sp             // r4 = &t[0]

    ldr     r10, [r4]           // r10 = t[0]
    mov     r11, #0
    umlal   r10, r11, r5 , r6   // r10 += lo(a[0]*b[i]), r11 = hi(a[0]*b[i])
    ldr     r9 , [r4, #4]       // r9 = t[1]
    mov     r12, #0
    mul     r8 , r10, r8        // q = lo( lo(a[0]*b[i]) * k0 )
    umlal   r10, r12, r8 , r7   // r10 += lo(q*n[0]), r12 = hi(q*n[0])

.LReduce:
    ldr     r5 , [r1], #4       // r5 = a[1], r1 += 4, points to a[2], equivalent to r5 = a[i++]
    adds    r10, r11, r9        // r10 = r11 + t[i+1]
    mov     r11, #0
    ldr     r7 , [r3], #4       // r7 = n[1], r3 += 4, points to n[2], equivalent to r7 = n[i++]
    adc     r11, r11, #0        // r11 saves the carry of the previous round.
                                // The carry is generated by the previous add
    mov     r14, #0
    umlal   r10, r11, r5 , r6   // r10 += lo(a[1]*b[0]), r11 = hi(a[1]*b[0])
    umlal   r12, r14, r8 , r7   // r12 += lo(q*n[1]), r14 = hi(q*n[1])
    adds    r12, r12, r10       // r12 = lo(S) + lo(a[1]*b[0]) + lo(q*n[1])
    str     r12, [r4], #4       // t[i] = r12, r4 = &t[i+1]
    adc     r12, r14, #0        // r12 = hi(S), hi(S) is lo(S) for the next loop
    ldr     r9 , [r4, #4]       // r9 = t[j+1]

    cmp     r4 , r0             // If r4 points to &t[size-1], perform special processing.
                                // In this case, r9 stores t[size]
    bne     .LReduce

    mov     r14, #0
    adds    r12, r12, r11       // r12 = hi(q*n[0]) + hi(a[i]*b[0]), hi(S) in the previous round, lo(S) in the last round
    adc     r14, r14, #0
    adds    r12, r12, r9        // r12 += t[size], Corresponding to +S in the formula,
                                // S=0 in the first round, so there is no need to add
    adc     r14, r14, #0

    ldr     r6 , [r4, #8]       // [r4, #4] = b[size], there's a problem here. It's not b[size], it's &b[size]

    str     r12, [r4], #4       // t[size-1], r4 +=4, points to t[size]
    str     r14, [r4]           // t[size]

    cmp     r2 , r6             // Check whether the outer loop is complete
    bne     .LCalculateQ

    ldr     r2 , [r4, #4*11]    // r2 = &r[0]
    sub     r12, r4 , sp        // r12 = size
    mov     r5 , sp             // r5 = &t[0]
    subs    r3 , r3 , r12       // r3 = &n[size] - size = &n[0], the subs is used to clear the CF to the zero

.LSubMod:
    ldr     r6 , [r5], #4       // t[i]
    ldr     r7 , [r3], #4       // n[i]
    sbcs    r6 , r6 , r7        // S - n, t[i] - n[i]
    str     r6 , [r2], #4       // r = S - n, result is temporarily stored in r
    teq     r0 , r5
    bne     .LSubMod

    // r8 = 0, r5 = &t[size-1]
    ldr     r6 , [r5], #4       // t[size-1]
    ldr     r7 , [r3]           // n[size-1]
    sbcs    r6 , r6 , r7        // t[size-1] - n[size-1]
    str     r6 , [r2], #4       // r[size-1] = t[size-1] - n[size-1], result is temporarily stored in r

    ldr     r6 , [r5]           // t[size]
    sbcs    r6 , r6 , #0        // Check the relationship between S and n based on the borrowing in this step.
                                // If there is borrowing, S < n

    bge     .LEnd               // Greater than or equal to jump, r = S - n

    mov     r5 , sp             // r5 = &t[0]
    sub     r2 , r2 , r12       // r2 = &r[size] - size = &r[0]
.LCopy:
    ldr     r6 , [r5], #4       // t[i]
    str     r6 , [r2], #4       // r[i] = t[i], r = S
    cmp     r5 , r0
    bne     .LCopy
    ldr     r6 , [r5], #4       // t[size-1]
    str     r6 , [r2], #4       // r[size-1] = t[size-1], r = S

.LEnd:
    mov     sp , r5             // r5 = &t[size]
    add     sp , sp, #8
    ldmia   sp!, {r4-r11, lr}
    add     sp , sp , #4        // r is pushed into the stack at the beginning, and an extra space is released.
    bx      lr
.size   MontMul_Asm,.-MontMul_Asm

#endif
